//C大数类
struct lint { int len = 0; int size = 0; int* v = NULL; };//length、size、value
#define lintminl 32
#define lintbase 100000000
#define lintchecksize(a, tsize) if ( (tsize) > (a)->size ||(tsize) >= lintminl && (tsize) * 2 <= (a)->size )lintresetsize(a, tsize)
#define lintnewstatic(a) static struct lint *a = NULL; if (a != NULL)lintresetv(a); else lintnew(&a)
														  //lint_basic
void lintresetsize(struct lint *a, int size) {
	int i = lintminl; while (i < size)i *= 2; int sizenew = i;
	int *vtemp = NULL; vtemp = new int[sizenew]; for (i = 0; i < sizenew; i++)vtemp[i] = 0;
	if (a->len > sizenew)a->len = sizenew; for (i = 0; i < a->len; i++)vtemp[i] = a->v[i];
	delete[]a->v; a->v = vtemp; a->size = sizenew; vtemp = NULL; return;
}
void lintresetv(struct lint *a) {
	int i; for (i = 0; i < a->len; i++)a->v[i] = 0; a->len = 0;
	return;
}
void lintnew(struct lint*a) {
	int size = lintminl;
	a->len = size; a->size = size;
	a->v = new int[size];
	lintresetv(a); return;
}
void lintnew(struct lint**ap) {
	*ap = NULL; *ap = new struct lint;
	lintnew(*ap); return;
}
void lintdelete(struct lint *a) {
	delete[]a->v; a->v = NULL; return;
}
void lintdelete(struct lint **ap) {
	lintdelete(*ap);
	delete *ap;
	*ap = NULL;
	return;
}
void lintcopy(struct lint *a, struct lint *b) {
	lintchecksize(a, b->len);
	lintresetv(a);
	int i; for (i = 0; i < b->len; i++) a->v[i] = b->v[i]; a->len = b->len;
	return;
}
int lintcmp(struct lint *a, struct lint *b) {
	//不支持负数
	if (a->len > b->len)return 1;
	if (a->len < b->len)return -1;
	int i = a->len;
	while (i--) {
		if (a->v[i] > b->v[i])return 1;
		if (a->v[i] < b->v[i])return -1;
	}
	return 0;
}
//lint_print
void lintprintf(struct lint *a) {
	int i, j, isfirst = 1;
	char dest[40096] = "\0", *destp = dest;
	for (i = a->len - 1; i >= 0; i--)
		if (isfirst) {
			isfirst = 0; if (a->v[i])destp += sprintf(destp, "%d", a->v[i]);
		}
		else if (destp - dest < 40000)destp += sprintf(destp, "%08d", a->v[i]);
		else { printf("%s", dest); destp = dest; for (j = 0; j < 40096; j++)dest[j] = 0; }
		if (isfirst)printf("0");
		else printf("%s", dest);
		printf("\n");
		return;
}
void lintsprintf(struct lint *a, char* temp0, int tempsize = -1) {
	int isfirst = 1, i; char* temp = temp0;
	if (tempsize != -1) {
		i = tempsize - 1;
		while (temp[i] == '\0'&&i >= 0)i--;
		temp += i + 1;
	}
	for (i = a->len - 1; i >= 0; i--) {
		if (isfirst) {
			if (a->v[i])temp += sprintf(temp, "%d", a->v[i]);
			isfirst = 0;
		}
		else temp += sprintf(temp, "%08d", a->v[i]);
		if (tempsize != -1 && temp - temp0 > tempsize - 8)return;
	}
	if (isfirst)temp += sprintf(temp, "0");
	temp += sprintf(temp, "\n");
	return;
}
//lint_add
void linta(struct lint *a, struct lint *b) {
	int i = a->len, n = b->len, temp = 0, base = lintbase;
	if (i < n)i = n; lintchecksize(a, i + 1);
	i = 0; while (1) {
		if (i < n)temp += b->v[i]; if (i >= n&&temp == 0)break;
		temp += a->v[i];
		a->v[i] = temp%base; temp /= base;
		i++;
	}
	if (a->len < i)a->len = i;
	return;
}
void linta(struct lint *a, int num, int section = 0) {
	struct lint b; lintnew(&b);
	lintchecksize(&b, section + 1); b.v[section] = num; b.len = section + 1;
	linta(a, &b);
	return;
}
//lint_sub
void lints(struct lint *a, struct lint *b) {
	//不支持负数
	int i, n = a->len, temp = 0, base = lintbase;
	for (i = 0; i < n; i++) {
		temp += a->v[i];
		if (i < b->len)temp -= b->v[i];
		if (temp >= 0) { a->v[i] = temp; temp = 0; if (i >= b->len)break; }
		else { a->v[i] = temp + base; temp = -1; }
	}
	for (i = a->len - 1; i >= 0; i--)if (a->v[i] != 0)break; a->len = i + 1;
	lintchecksize(a, a->len);
	return;
}
void lints(struct lint *a, int num, int section = 0) {
	struct lint b; lintnew(&b);
	lintchecksize(&b, section + 1); b.v[section] = num; b.len = section + 1;
	lints(a, &b);
	return;
}
//lint_muti
void lintm0(struct lint *a, struct lint *b) {
	if (a->len == 1 && a->v[0] == 1) {
		lintcopy(a, b);
		return;
	}
	int i = a->len + b->len, j;
	lintnewstatic(c); lintchecksize(c, i);
	long long temp, temp2, base = lintbase;
	temp = 0;
	for (i = 0; i < a->len + b->len; i++) {
		for (j = 0; j <= i; j++) {
			temp2 = 1;
			if (j < a->len)temp2 *= a->v[j]; else continue;
			if (i - j < b->len)temp2 *= b->v[i - j]; else continue;
			temp += temp2;
		}
		c->v[i] = temp%base; temp /= base;
	}
	i = c->size - 1; while (c->v[i] == 0)i--; c->len = i + 1;
	lintcopy(a, c);
	return;
}
void lintm1div(struct lint*d, struct lint*s, int end, int start) {
	if (end > s->len)end = s->len;
	if (end <= start)return;
	lintchecksize(d, end - start);
	int i; for (i = start; i < end; i++)d->v[i - start] = s->v[i];
	d->len = end - start; while (d->len>0 && d->v[d->len - 1] == 0)d->len--;
	return;
}
#define lintm1divmain(x, y, a, b, c, d, e, f, n) lintm1div(a, x, x->len, n); lintm1div(b, x, n, 0); lintm1div(c, y, y->len, n); lintm1div(d, y, n, 0); lintcopy(e, a); linta(e, b); lintcopy(f, c); linta(f, d)
void lintm1sum(struct lint *q, struct lint *p, struct lint *k, int n) {
	struct lint *re = NULL; lintnew(&re); int i;
	if (k->len) {
		lints(k, q); lints(k, p);
		lintchecksize(k, k->len + n);
		for (i = k->len - 1; i >= 0; i--) { k->v[i + n] = k->v[i]; k->v[i] = 0; }
		k->len += n;
		linta(re, k);
	}
	if (q->len) {
		lintchecksize(q, q->len + n * 2);
		for (i = q->len - 1; i >= 0; i--) { q->v[i + n * 2] = q->v[i]; q->v[i] = 0; }
		q->len += n * 2;
		linta(re, q);
	}
	linta(re, p);
	lintcopy(q, re);
	lintdelete(&re);
	return;
};
void lintm1(struct lint *x, struct lint *y) {
	if (x->len == 0 || y->len == 0) {
		lintresetv(x);
		return;
	}
	if (x->len <= 128 && y->len <= 128) {
		lintm0(x, y); return;
	}
	int n = x->len; if (n < y->len)n = y->len; n = n / 2;
	struct lint *a = NULL, *b = NULL, *c = NULL, *d = NULL, *e = NULL, *f = NULL;
	lintnew(&a); lintnew(&b); lintnew(&c); lintnew(&d); lintnew(&e); lintnew(&f);
	lintm1divmain(x, y, a, b, c, d, e, f, n);
	lintm1(a, c); lintm1(b, d); lintm1(e, f);
	lintm1sum(a, b, e, n);
	lintcopy(x, a);
	lintdelete(&a); lintdelete(&b); lintdelete(&c); lintdelete(&d); lintdelete(&e); lintdelete(&f);
	return;
}
struct lintm1 { int len = 0; int size = 0; struct lint **stack = NULL; int*posj = NULL; int *n = NULL; };
#define lintm1minl 64
#define lintm1checksize(s, tsize) if ( (tsize) > (s)->size||(tsize) >= lintm1minl && (tsize) * 2 <= (s)->size  )lintm1resetsize(s, tsize)
#define lintm1return for (i = curi * 6; i < curi * 6 + 6; i++)lintresetv(s->stack[i]); s->n[curi] = 0; s->posj[curi] = 0; s->len--; curi = s->len - 1; curj = s->posj[curi]; continue
#define lintm1recursive s->posj[curi] = curj; lintm1checksize(s, s->len + 1); s->len++; curi = s->len - 1; curj = 0; continue
void lintm1resetsize(struct lintm1 *a, int size) {
	int i = lintm1minl; while (i < size)i *= 2; size = i;
	//stack
	struct lint**temp = NULL; temp = new struct lint*[size * 6]; for (i = 0; i < size * 6; i++)temp[i] = NULL;
	if (size < a->size) {
		for (i = size * 6; i < a->size * 6; i++)lintdelete(a->stack + i);
		a->size = size;
	}
	for (i = 0; i < a->size * 6; i++) { temp[i] = a->stack[i]; }
	for (i = 0; i < a->size * 6; i++)a->stack[i] = NULL;
	for (i = a->size * 6; i < size * 6; i++)lintnew(temp + i);
	delete[]a->stack; a->stack = temp; a->size = size;
	//其余
	int*t2 = NULL; t2 = new int[size]; for (i = 0; i < size; i++)t2[i] = 0; for (i = 0; i < a->len; i++)t2[i] = a->n[i]; delete[]a->n; a->n = t2; t2 = NULL;
	t2 = new int[size]; for (i = 0; i < size; i++)t2[i] = 0; for (i = 0; i < a->len; i++)t2[i] = a->posj[i]; delete[]a->posj; a->posj = t2; t2 = NULL;
}
void lintm1s(struct lint *x, struct lint *y) {
	int lim = 128;
	if (x->len == 0 || y->len == 0) {
		lintresetv(x);
		return;
	}
	if (x->len <= lim && y->len <= lim) {
		lintm0(x, y); return;
	}
	//创建一个栈 用来避免递归
	int i;
	static int isnew = 1;
	static struct lintm1 *s = NULL;
	if (isnew) {
		isnew = 0; s = new struct lintm1; lintm1checksize(s, lintm1minl);
	}
	int curi = 0, curj = 0, sx = 0, sy = 0, t1 = 0, t2 = 0, a, b, c, d, e, f;
	//主程序
	s->n[0] = x->len; if (s->n[0] < y->len)s->n[0] = y->len; s->n[0] = s->n[0] / 2;
	lintm1divmain(x, y, s->stack[0], s->stack[2], s->stack[1], s->stack[3], s->stack[4], s->stack[5], s->n[0]);
	s->posj[0] = 1;
	s->len += 1;
	curi = 0; curj = 1;

	while (curi >= 0) {
		if (curj <= 0) {
			curj = 1;
			//计算坐标
			t1 = curi - 1; t2 = s->posj[t1];//上一步的posi与posj
			sx = t1 * 6 + (t2 - 2) * 2; sy = sx + 1;
			a = curi * 6 + 0; b = curi * 6 + 2; c = curi * 6 + 1;
			d = curi * 6 + 3; e = curi * 6 + 4; f = curi * 6 + 5;
			//不需要继续切分
			if (s->stack[sx]->len == 0 || s->stack[sy]->len == 0) {
				lintresetv(s->stack[sx]); lintm1return;
			}
			if (s->stack[sx]->len <= lim && s->stack[sy]->len <= lim) {
				lintm0(s->stack[sx], s->stack[sy]); lintm1return;
			}
			//继续切分
			s->n[curi] = s->stack[sx]->len; if (s->n[curi] < s->stack[sy]->len)s->n[curi] = s->stack[sy]->len; s->n[curi] = s->n[curi] / 2;
			lintm1divmain(s->stack[sx], s->stack[sy], s->stack[a], s->stack[b], s->stack[c], s->stack[d], s->stack[e], s->stack[f], s->n[curi]);
		}
		//递归计算a*c
		if (curj <= 1) {
			curj = 2; lintm1recursive;
		}
		//递归计算b*d
		if (curj <= 2) {
			curj = 3; lintm1recursive;
		}
		//递归计算e*f
		if (curj <= 3) {
			curj = 4; lintm1recursive;
		}
		//lintsum
		a = curi * 6 + 0; b = curi * 6 + 2; c = curi * 6 + 1;
		d = curi * 6 + 3; e = curi * 6 + 4; f = curi * 6 + 5;
		lintm1sum(s->stack[a], s->stack[b], s->stack[e], s->n[curi]);
		//传值
		if (curi == 0)lintcopy(x, s->stack[0]);
		else {
			//计算坐标
			t1 = curi - 1; t2 = s->posj[t1];
			sx = t1 * 6 + (t2 - 2) * 2; sy = sx + 1;
			lintcopy(s->stack[sx], s->stack[a]);
		}
		lintm1return;
	}
	return;
}
void lintm(struct lint *a, struct lint *b) {
	switch (3) {
	case 1:lintm0(a, b); return;//原始竖式乘法 o(n^2)
	case 2:lintm1(a, b); return;//分治乘法 o(n^1.59)
	case 3:lintm1s(a, b); return;//带有栈管理的分治乘法 o(n^1.59)
	}
}
void lintm(struct lint *a, int num, int section = 0) {
	lintnewstatic(c); lintchecksize(c, section + 1);
	linta(c, num, section);
	lintm(a, c); return;
}
//lint_div
int lintd(struct lint *a, struct lint *b) {
	lintnewstatic(c); lintchecksize(c, a->len);
	lintnewstatic(d); lintchecksize(d, a->len);
	lintnewstatic(e); lintchecksize(e, a->len);
	int i;
	while (lintcmp(a, b) != -1) {
		lintresetv(d); linta(d, 1);
		while (1) {
			lintcopy(e, b); lintm(e, d); lintm(e, 10);
			if (lintcmp(a, e) == -1)break;
			lintm(d, 10);
		}
		i = 1;
		while (1) {
			lintcopy(e, b); lintm(e, d); lintm(e, i + 1);
			if (lintcmp(a, e) == -1)break;
			i++;
		}
		lintcopy(e, b); lintm(d, i); lintm(e, d);
		linta(c, d);
		lints(a, e);
	}
	int re = 0;
	lintresetv(d);
	if (lintcmp(a, d) == 0)re = 0; else re = 1;
	i = c->len - 1; while (c->v[i] == 0 && i >= 0)i--; c->len = i + 1;
	lintcopy(a, c);
	return re;
}
void lintd(struct lint *a, int num, int section = 0) {
	lintnewstatic(c); lintchecksize(c, a->len);
	linta(c, num, section);
	lintd(a, c); return;
}
