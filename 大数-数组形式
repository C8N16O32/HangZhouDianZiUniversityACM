//C大数类
struct lint { int len = 0; int size = 0; int* v = NULL; };//length、size、value
#define lintminl 64
#define lintbase 100000000
#define lintchecksize(a, tsize) if ( (tsize) > (a)->size ||(tsize) >= lintminl && (tsize) * 2 <= (a)->size )lintresetsize(a, tsize)
#define lintnewstatic(a) static lint *a = NULL; if (a != NULL)lintresetv(a); else lintnew(&a)
  //lint_basic
void lintresetsize(lint *a, int size) {
	int i = lintminl; while (i < size)i *= 2; int sizenew = i;
	int *vtemp = NULL; vtemp = new int[sizenew]; for (i = 0; i < sizenew; i++)vtemp[i] = 0;
	if (a->len > sizenew)a->len = sizenew; for (i = 0; i < a->len; i++)vtemp[i] = a->v[i];
	delete[]a->v; a->v = vtemp; a->size = sizenew; vtemp = NULL; return;
}
void lintresetv(lint *a) {
	char *av = (char*)(a->v);//优化
	int I = a->len*sizeof(int);
	for (int i = 0; i < I; i++)av[i] = '\0'; a->len = 0;
	return;
}
void lintnew(lint*a) {
	int size = lintminl;
	a->len = size; a->size = size;
	a->v = new int[size];
	lintresetv(a); return;
}
void lintnew(lint **ap) {
	*ap = new lint;
	lintnew(*ap); return;
}
void lintdelete(lint *a) {
	delete[]a->v; a->v = NULL; return;
}
void lintdelete(lint **ap) {
	lintdelete(*ap);
	delete *ap;
	*ap = NULL;
	return;
}
void lintshift(lint *a, int n) {
	lintchecksize(a, a->len + n);
	int *av = a->v;
	for (int i = a->len - 1; i >= 0; i--) { av[i + n] = av[i]; av[i] = 0; }
	a->len += n; return;
}
void lintcopy(lint *a, lint *b) {
	lintresetv(a); lintchecksize(a, b->len);
	char*av = (char*)a->v, *bv = (char*)b->v;//优化
	int I = b->len*sizeof(int);
	for (int i = 0; i < I; i++) av[i] = bv[i]; a->len = b->len;
	return;
}
int lintcmp(lint *a, lint *b) {
	//不支持负数
	if (a->len > b->len)return 1;
	if (a->len < b->len)return -1;
	int i = a->len;
	while (i--) {
		if (a->v[i] > b->v[i])return 1;
		if (a->v[i] < b->v[i])return -1;
	}
	return 0;
}
//lint_print
void lintprintfvalue(lint *a) {
	int i, j, isfirst = 1;
	char dest[40096] = "\0", *destp = dest;
	for (i = a->len - 1; i >= 0; i--)
		if (isfirst) {
			isfirst = 0; if (a->v[i])destp += sprintf(destp, "%d", a->v[i]);
		}
		else if (destp - dest < 40000)destp += sprintf(destp, "%08d", a->v[i]);
		else { printf("%s", dest); destp = dest; for (j = 0; j < 40096; j++)dest[j] = 0; }
		if (isfirst)printf("0");
		else printf("%s", dest);
		return;
}
void lintprintfstrlen(lint *a) {
	//长度
	int i = a->v[a->len - 1], j = 0;
	while (i > 0) { i /= 10; j++; }
	printf("%d", j - 8 + a->len * 8);
	//长度 end
}
void lintprintf(lint *a) {
	lintprintfvalue(a);
	printf("\n解的总长度：");
	lintprintfstrlen(a);
	printf("\n");
	return;
}
void lintsprintf(lint *a, char* temp0, int tempsize = -1) {
	int isfirst = 1, i; char* temp = temp0;
	if (tempsize != -1) {
		i = tempsize - 1;
		while (temp[i] == '\0'&&i >= 0)i--;
		temp += i + 1;
	}
	for (i = a->len - 1; i >= 0; i--) {
		if (isfirst) {
			if (a->v[i])temp += sprintf(temp, "%d", a->v[i]);
			isfirst = 0;
		}
		else temp += sprintf(temp, "%08d", a->v[i]);
		if (tempsize != -1 && temp - temp0 > tempsize - 8)return;
	}
	if (isfirst)temp += sprintf(temp, "0");
	temp += sprintf(temp, "\n");
	return;
}
//lint_add
void linta(lint *a, lint *b) {
	int i = a->len, n = b->len; if (i < n)i = n;
	lintchecksize(a, i + 1);
	int temp = 0, base = lintbase;
	int *av = a->v, *bv = b->v;//优化
	i = 0; while (i < b->len&&bv[i] == 0)i++;
	while (1) {
		if (i < b->len)temp += bv[i];
		else if (temp == 0)break;
		temp += av[i];
		av[i] = temp%base; temp /= base; i++;
	}
	if (a->len < i)a->len = i;
	return;
}
void linta(lint *a, int num, int section = 0) {
	lintnewstatic(b); lintchecksize(b, section + 1);
	b->v[section] = num; b->len = section + 1;
	linta(a, b);
	return;
}
void lintafast(lint *a, long long num, int sect = 0, int sect2 = 0) {
	if (num <= 0)return;
	int i, j, base = lintbase, base2 = 1; for (i = 0; i < sect2; i++)base2 *= 10; base = lintbase / base2;
	int temp[4] = { 0 };
	temp[0] = num%base*base2; num /= base;
	i = 1; while (num) { temp[i] = num%lintbase; num /= lintbase; i++; }
	int*v = a->v, size = a->size;//优化
	i = 0; j = 0; while (j < 4 && temp[j] != 0)j++;
	base2 = 0;
	while (sect + i < size) {
		if (i < j)v[sect + i] += temp[i];
		v[sect + i] += base2; base2 = 0;
		if (v[sect + i] >= lintbase) { base2 = v[sect + i] / lintbase; v[sect + i] %= lintbase; }
		else if (i >= j)break;
		i++;
	}
	if (base2) { i++; lintchecksize(a, sect + i); a->v[sect + i - 1] = base2; }
	a->len = sect + i; return;
}
//lint_sub
void lints(lint *a, lint *b) {
	//不支持负数
	int i, n = a->len, temp = 0, base = lintbase;
	i = 0; while (i < b->len&&b->v[i] == 0)i++;
	while (1) {
		if (i < b->len)temp -= b->v[i];
		else if (temp == 0)break;
		temp += a->v[i];
		if (temp >= 0) { a->v[i] = temp; temp = 0; }
		else { a->v[i] = temp + base; temp = -1; }
		i++;
	}
	for (i = a->len - 1; i >= 0; i--)if (a->v[i] != 0)break; a->len = i + 1;
	lintchecksize(a, a->len);
	return;
}
void lints(lint *a, int num, int section = 0) {
	lintnewstatic(b); lintchecksize(b, section + 1);
	b->v[section] = num; b->len = section + 1;
	lints(a, b);
	return;
}
//lint_muti
#define lintm2minl 1024
#define lintm2maxl 2097152
void lintm2(lint *x, lint *y);
void lintm0(lint *a, lint *b) {
	if (b->len == 1 && b->v[0] == 1) {
		return;
	}
	if (a->len == 1 && a->v[0] == 1) {
		lintcopy(a, b);
		return;
	}
	if (a->len == 0 || b->len == 0) {
		lintresetv(a); lintchecksize(a, 0);
		return;
	}
	int i, j, I, al = a->len, bl = b->len, I2 = al + bl; long long temp = 0, temp2, base = lintbase;
	lintnewstatic(c); lintchecksize(c, I2);
	int *av = a->v, *bv = b->v, *cv = c->v;//优化
	i = 0; while (i < al&&av[i] == 0)i++;
	j = 0; while (j < bl&&bv[j] == 0)j++; I = i + j;
	for (i = I; i < I2; i++) {
		for (j = 0; j <= i; j++) {
			temp2 = 1;
			if (j < al)temp2 *= av[j]; else continue;
			if (i - j < bl)temp2 *= bv[i - j]; else continue;
			temp += temp2;
			if (j % 400 == 399) { lintafast(c, temp / base, i + 1); temp %= base; }
		}
		lintafast(c, temp%base, i); temp /= base;
	}
	i = c->size - 1; while (cv[i] == 0)i--; c->len = i + 1;
	lintcopy(a, c);
	return;
}
//分治乘法
void lintm1div(lint *d, lint *s, int end, int start) {
	if (end > s->len)end = s->len;
	if (end <= start)return;
	lintchecksize(d, end - start);
	int i; for (i = start; i < end; i++)d->v[i - start] = s->v[i];
	d->len = end - start; while (d->len>0 && d->v[d->len - 1] == 0)d->len--;
	return;
}
#define lintm1divmain(x, y, a, b, c, d, e, f, n) lintm1div(a, x, x->len, n); lintm1div(b, x, n, 0); lintm1div(c, y, y->len, n); lintm1div(d, y, n, 0); lintcopy(e, a); linta(e, b); lintcopy(f, c); linta(f, d)
void lintm1sum(lint *q, lint *p, lint *k, int n) {
	lint *re = NULL; lintnew(&re);
	if (k->len) {
		lints(k, q); lints(k, p);
		lintshift(k, n);
		linta(re, k);
	}
	if (q->len) {
		lintshift(q, n * 2);
		linta(re, q);
	}
	linta(re, p);
	lintcopy(q, re);
	lintdelete(&re);
	return;
}
void lintm1(lint *x, lint *y) {
	if (y->len == 1 && y->v[0] == 1) {
		return;
	}
	if (x->len == 1 && x->v[0] == 1) {
		lintcopy(x, y);
		return;
	}
	if (x->len == 0 || y->len == 0) {
		lintresetv(x); lintchecksize(x, 0);
		return;
	}
	if (x->len >= lintm2minl && y->len >= lintm2minl)
		if (x->len < lintm2maxl && y->len < lintm2maxl) {
			lintm2(x, y); return;
		}
	if (x->len <= 256 && y->len <= 256) {
		lintm0(x, y); return;
	}
	int n = x->len; if (n < y->len)n = y->len; n = n / 2;
	lint *a = NULL, *b = NULL, *c = NULL, *d = NULL, *e = NULL, *f = NULL;
	lintnew(&a); lintnew(&b); lintnew(&c); lintnew(&d); lintnew(&e); lintnew(&f);
	lintm1divmain(x, y, a, b, c, d, e, f, n);
	lintm1(a, c); lintdelete(&c); 
	lintm1(b, d); lintdelete(&d);
	lintm1(e, f); lintdelete(&f);
	lintm1sum(a, b, e, n);
	lintcopy(x, a);
	lintdelete(&a); lintdelete(&b); lintdelete(&c); lintdelete(&d); lintdelete(&e); lintdelete(&f);
	return;
}
//FFT乘法
struct comp { double x, y; };
const double pi = acos(-1);
void coswap(comp *a, comp *b) {
	double temp;
	temp = a->x; a->x = b->x; b->x = temp;
	temp = a->y; a->y = b->y; b->y = temp; return;
}
void coa(comp *a, comp *b) {
	a->x += b->x; a->y += b->y; return;
}
void cos(comp *a, comp *b) {
	a->x -= b->x; a->y -= b->y; return;
}
void com(comp *a, const comp b) {
	double x = a->x*b.x - a->y*b.y;
	double y = a->x*b.y + a->y*b.x;
	a->x = x; a->y = y; return;
}
void lintm2_rev(int **rev, int*size, int len) {
	int i, tim = 0, s = 1;
	while (s < len) { s <<= 1; tim++; }
	*rev = new int[s]; for (i = 0; i < s; i++)(*rev)[i] = 0;
	for (i = 0; i < s; i++)(*rev)[i] = ((*rev)[i >> 1] >> 1) | ((i & 1) << (tim - 1));
	*size = s;
	return;
}
void lintm2_FFT(comp*a, const int fla, int *rev, int size) {
	int i, j, k;
	for (i = 0; i < size; i++)if (i < rev[i])coswap(a + i, a + rev[i]);
	for (i = 1; i < size; i <<= 1) {
		const comp w = { cos(pi / i), fla*sin(pi / i) };
		for (j = 0; j < size; j += (i << 1)) {
			comp K = { 1,0 };
			for (k = 0; k < i; k++) {
				com(&K, w);
				comp x = a[j + k], y = a[j + k + i];
				com(&y, K);
				a[j + k] = x; coa(a + j + k, &y);
				a[j + k + i] = x; cos(a + j + k + i, &y);
			}
		}
	}
	for (i = 0; i < size / 2; i++)coswap(a + i, a + size - i - 1);
	return;
}
void lintm2(lint *x, lint *y) {
	if (y->len == 1 && y->v[0] == 1) {
		return;
	}
	if (x->len == 1 && x->v[0] == 1) {
		lintcopy(x, y);
		return;
	}
	if (x->len == 0 || y->len == 0) {
		lintresetv(x); lintchecksize(x, 0);
		return;
	}
	int i, j, temp, *rev = NULL, size = 0;
	i = x->len + y->len;
	lintm2_rev(&rev, &size, i * 8);
	//a,b传值
	comp*a = NULL;
	while (a == NULL)a = new comp[size];
	for (i = 0; i < size; i++) { a[i].x = 0; a[i].y = 0; };
	for (i = 0; i < x->len; i++) {
		temp = x->v[i];
		j = 0;
		while (temp > 0) {
			a[i * 8 + j].x = temp % 10;
			temp /= 10;
			j++;
		}
	}
	for (i = 0; i < y->len; i++) {
		temp = y->v[i];
		j = 0;
		while (temp > 0) {
			a[i * 8 + j].y = temp % 10;
			temp /= 10;
			j++;
		}
	}
	//正变换
	lintm2_FFT(a, 1, rev, size);
	//a[i]=a[i].*a[i]
	for (i = 0; i < size; i++)com(a + i, a[i]);
	//反变换
	lintm2_FFT(a, -1, rev, size);
	//归一化
	for (i = 0; i < size; i++)a[i].x = a[i].y / size / 2;
	//x 传值
	long long temp2;
	lintresetv(x);
	lintchecksize(x, size / 8);
	for (i = 0; i < size; i++) {
		temp2 = (int)(a[i].x + 0.49);
		lintafast(x, temp2, i / 8, i % 8);
	}
	x->len = x->size - 1; while (x->v[x->len] == 0)x->len--; x->len++;
	//回收空间
	delete[]rev; delete[]a;
	return;
}
void lintm(lint *a, lint *b, int mode = 2) {
	switch (mode) {
	case 1:lintm0(a, b); return;//原始竖式乘法 o(n^2)
	case 2:lintm1(a, b); return;//分治乘法 o(n^1.59)
	//case 3:lintm1s(a, b); return;//手动设置一个栈的乘法2 o(n^1.59) 优化效果不明显
	case 4:lintm2(a, b); return;//FFT乘法 ≈o(n)
	}
}
void lintm(lint *a, int num, int section = 0, int mode = 2) {
	lintnewstatic(c); lintchecksize(c, section + 1);
	linta(c, num, section);
	lintm(a, c, mode); return;
}
//lint_div
int lintd(lint *a, lint *b) {
	lintnewstatic(c); lintchecksize(c, a->len);
	lintnewstatic(d); lintchecksize(d, a->len);
	lintnewstatic(e); lintchecksize(e, a->len);
	int i;
	while (lintcmp(a, b) != -1) {
		lintresetv(d); linta(d, 1);
		while (1) {
			lintcopy(e, b); lintm(e, d); lintm(e, 10);
			if (lintcmp(a, e) == -1)break;
			lintm(d, 10);
		}
		i = 1;
		while (1) {
			lintcopy(e, b); lintm(e, d); lintm(e, i + 1);
			if (lintcmp(a, e) == -1)break;
			i++;
		}
		lintcopy(e, b); lintm(d, i); lintm(e, d);
		linta(c, d);
		lints(a, e);
	}
	int re = 0;
	lintresetv(d);
	if (lintcmp(a, d) == 0)re = 0; else re = 1;
	i = c->len - 1; while (c->v[i] == 0 && i >= 0)i--; c->len = i + 1;
	lintcopy(a, c);
	return re;
}
void lintd(lint *a, int num, int section = 0) {
	lintnewstatic(c); lintchecksize(c, a->len);
	linta(c, num, section);
	lintd(a, c); return;
}
//二分乘法
#define lintmslen 32
#define lintmsminl 16
void lintmsnew(lint**temp) {
	for (int i = 0; i < lintmslen; i++) { lintnew(temp + i); linta(temp[i], 1); }return;
}
void lintmsnew(lint***ptemp) {
	*ptemp = new lint*[lintmslen];
	lintmsnew(*ptemp); return;
}
void lintmsdelete(lint***ptemp) {
	for (int i = 0; i < lintmslen; i++)lintdelete(*ptemp + i);
	delete[] * ptemp; *ptemp = NULL; return;
}
void lintmsresetv(lint**temp) {
	for (int i = 0; i < lintmslen; i++) { lintresetv(temp[i]); temp[i]->v[0] = 1; temp[i]->len = 1; }return;
}
void lintms(lint**temp, int n, int section = 0) {
	int ti = 0; int tb = lintmsminl;
	lintm(temp[0], n, section);
	while (temp[ti]->len >= tb) {
		lintm(temp[ti + 1], temp[ti]);
		lintresetv(temp[ti]); temp[ti]->v[0] = 1; temp[ti]->len = 1;
		tb *= 2; ti++;
	}
	return;
}
void lintms(lint**temp, lint *a) {
	int ti = 0; int tb = lintmsminl;
	while (ti<lintmslen&&a->len >= tb) {
		tb *= 2; ti++;
	}
	lintm(temp[ti], a);
	while (temp[ti]->len >= tb) {
		lintm(temp[ti + 1], temp[ti]);
		lintresetv(temp[ti]); temp[ti]->v[0] = 1; temp[ti]->len = 1;
		tb *= 2; ti++;
	}
	return;
}
void lintms(lint**temp, lint**temp2) {
	for (int i = 0; i < lintmslen; i++)lintms(temp, temp2[i]); return;
}
void lintms2lint(lint**temp, lint *a) {
	for (int i = 0; i < lintmslen; i++)lintm(a, temp[i]); return;
}
