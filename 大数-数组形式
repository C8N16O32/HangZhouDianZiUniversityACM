//C大数类
struct lint { int len = 0; int size = 0; int* v = NULL; };//length、size、value
#define lintminl 64
#define lintbase 100000000
#define lintchecksize(a, tsize) if ( (tsize) > (a)->size ||(tsize) >= lintminl && (tsize) * 2 <= (a)->size )lintresetsize(a, tsize)
#define lintnewstatic(a) static lint *a = NULL; if (a != NULL)lintresetv(a); else lintnew(&a)
//lint_basic
void lintresetsize(lint *a, int size) {
	int i = lintminl; while (i < size)i *= 2; int sizenew = i;
	int *vtemp = NULL; vtemp = new int[sizenew]; for (i = 0; i < sizenew; i++)vtemp[i] = 0;
	if (a->len > sizenew)a->len = sizenew; for (i = 0; i < a->len; i++)vtemp[i] = a->v[i];
	delete[]a->v; a->v = vtemp; a->size = sizenew; vtemp = NULL; return;
}
void lintresetv(lint *a) {
	int i; for (i = 0; i < a->len; i++)a->v[i] = 0; a->len = 0;
	return;
}
void lintnew(lint*a) {
	int size = lintminl;
	a->len = size; a->size = size;
	a->v = new int[size];
	lintresetv(a); return;
}
void lintnew(lint **ap) {
	*ap = NULL; *ap = new lint;
	lintnew(*ap); return;
}
void lintdelete(lint *a) {
	delete[]a->v; a->v = NULL; return;
}
void lintdelete(lint **ap) {
	lintdelete(*ap);
	delete *ap;
	*ap = NULL;
	return;
}
void lintcopy(lint *a, lint *b) {
	lintchecksize(a, b->len);
	lintresetv(a);
	int i; for (i = 0; i < b->len; i++) a->v[i] = b->v[i]; a->len = b->len;
	return;
}
int lintcmp(lint *a, lint *b) {
	//不支持负数
	if (a->len > b->len)return 1;
	if (a->len < b->len)return -1;
	int i = a->len;
	while (i--) {
		if (a->v[i] > b->v[i])return 1;
		if (a->v[i] < b->v[i])return -1;
	}
	return 0;
}
//lint_print
void lintprintf(lint *a) {
	int i, j, isfirst = 1;
	char dest[40096] = "\0", *destp = dest;
	for (i = a->len - 1; i >= 0; i--)
		if (isfirst) {
			isfirst = 0; if (a->v[i])destp += sprintf(destp, "%d", a->v[i]);
		}
		else if (destp - dest < 40000)destp += sprintf(destp, "%08d", a->v[i]);
		else { printf("%s", dest); destp = dest; for (j = 0; j < 40096; j++)dest[j] = 0; }
		if (isfirst)printf("0");
		else printf("%s", dest);
		printf("\n");
		//长度
		i = a->v[a->len - 1]; j = 0;
		while (i > 0) { i /= 10; j++; }
		printf("解的总长度：%d\n", j - 8 + a->len * 8);
		//长度 end
		return;
}
void lintsprintf(lint *a, char* temp0, int tempsize = -1) {
	int isfirst = 1, i; char* temp = temp0;
	if (tempsize != -1) {
		i = tempsize - 1;
		while (temp[i] == '\0'&&i >= 0)i--;
		temp += i + 1;
	}
	for (i = a->len - 1; i >= 0; i--) {
		if (isfirst) {
			if (a->v[i])temp += sprintf(temp, "%d", a->v[i]);
			isfirst = 0;
		}
		else temp += sprintf(temp, "%08d", a->v[i]);
		if (tempsize != -1 && temp - temp0 > tempsize - 8)return;
	}
	if (isfirst)temp += sprintf(temp, "0");
	temp += sprintf(temp, "\n");
	return;
}
//lint_add
void linta(lint *a, lint *b) {
	int i = a->len, n = b->len, temp = 0, base = lintbase;
	if (i < n)i = n; lintchecksize(a, i + 1);
	i = 0; while (i < n&&b->v[i] == 0)i++;
	while (1) {
		if (i < n)temp += b->v[i]; if (i >= n&&temp == 0)break;
		temp += a->v[i];
		a->v[i] = temp%base; temp /= base;
		i++;
	}
	if (a->len < i)a->len = i;
	return;
}
void linta(lint *a, int num, int section = 0) {
	lintnewstatic(b); lintchecksize(b, section + 1);
	b->v[section] = num; b->len = section + 1;
	linta(a, b);
	return;
}
int lintafast(lint *a, long long num, int section = 0, int section2 = 0) {
	if (num <= 0)return num;
	int i, base = lintbase, base2 = 1; for (i = 0; i < section2; i++)base2 *= 10; base = lintbase / base2;
	long long temp0 = 0, temp1 = 0, temp2 = 0, temp3 = 0;
	temp0 = num%base*base2;
	if (num) { num /= base; temp1 = num %lintbase; }
	if (num) { num /= lintbase; temp2 = num%lintbase; }
	if (num) { num /= lintbase; temp3 = num; }

	int s0 = section;
	i = section; if (i >= a->size)return i;
	a->v[section] += temp0; if (a->v[section] >= lintbase) { temp1 += a->v[section] / lintbase; a->v[section] %= lintbase; }section++;
	if (temp1) { i = section; if (i >= a->size)return i; a->v[section] += temp1; if (a->v[section] >= lintbase) { temp2 += a->v[section] / lintbase; a->v[section] %= lintbase; } }section++;
	if (temp2) { i = section; if (i >= a->size)return i; a->v[section] += temp2; if (a->v[section] >= lintbase) { temp3 += a->v[section] / lintbase; a->v[section] %= lintbase; } }section++;
	if (temp3) { i = section; if (i >= a->size)return i; a->v[section] += temp3; }
	while (section < a->size&&a->v[section] >= lintbase) {
		a->v[section + 1] += a->v[section] / lintbase; a->v[section] %= lintbase;
		section += 1; i = section; if (i >= a->size)return i;
	}
	return i;
}
//lint_sub
void lints(lint *a, lint *b) {
	//不支持负数
	int i, n = a->len, temp = 0, base = lintbase;
	for (i = 0; i < n; i++) {
		if (i < b->len&&b->v[i] == 0 && temp == 0)continue;
		temp += a->v[i];
		if (i < b->len)temp -= b->v[i];
		if (temp >= 0) { a->v[i] = temp; temp = 0; if (i >= b->len)break; }
		else { a->v[i] = temp + base; temp = -1; }
	}
	for (i = a->len - 1; i >= 0; i--)if (a->v[i] != 0)break; a->len = i + 1;
	lintchecksize(a, a->len);
	return;
}
void lints(lint *a, int num, int section = 0) {
	lintnewstatic(b); lintchecksize(b, section + 1);
	b->v[section] = num; b->len = section + 1;
	lints(a, b);
	return;
}
//lint_muti
#define lintm2minl 1024
#define lintm2maxl 2097152
void lintm2(lint *x, lint *y);
void lintm0(lint *a, lint *b) {
	int i = a->len + b->len, j;
	lintnewstatic(c); lintchecksize(c, i);
	long long temp, temp2, base = lintbase;
	temp = 0;
	for (i = 0; i < a->len + b->len; i++) {
		for (j = 0; j <= i; j++) {
			temp2 = 1;
			if (j < a->len)temp2 *= a->v[j]; else continue;
			if (i - j < b->len)temp2 *= b->v[i - j]; else continue;
			temp += temp2;
		}
		c->v[i] = temp%base; temp /= base;
	}
	i = c->size - 1; while (c->v[i] == 0)i--; c->len = i + 1;
	lintcopy(a, c);
	return;
}
void lintm1div(lint *d, lint *s, int end, int start) {
	if (end > s->len)end = s->len;
	if (end <= start)return;
	lintchecksize(d, end - start);
	int i; for (i = start; i < end; i++)d->v[i - start] = s->v[i];
	d->len = end - start; while (d->len>0 && d->v[d->len - 1] == 0)d->len--;
	return;
}
#define lintm1divmain(x, y, a, b, c, d, e, f, n) lintm1div(a, x, x->len, n); lintm1div(b, x, n, 0); lintm1div(c, y, y->len, n); lintm1div(d, y, n, 0); lintcopy(e, a); linta(e, b); lintcopy(f, c); linta(f, d)
void lintm1sum(lint *q, lint *p, lint *k, int n) {
	lint *re = NULL; lintnew(&re); int i;
	if (k->len) {
		lints(k, q); lints(k, p);
		lintchecksize(k, k->len + n);
		for (i = k->len - 1; i >= 0; i--) { k->v[i + n] = k->v[i]; k->v[i] = 0; }
		k->len += n;
		linta(re, k);
	}
	if (q->len) {
		lintchecksize(q, q->len + n * 2);
		for (i = q->len - 1; i >= 0; i--) { q->v[i + n * 2] = q->v[i]; q->v[i] = 0; }
		q->len += n * 2;
		linta(re, q);
	}
	linta(re, p);
	lintcopy(q, re);
	lintdelete(&re);
	return;
};
void lintm1(lint *x, lint *y) {
	if (y->len == 1 && y->v[0] == 1) {
		return;
	}
	if (x->len == 1 && x->v[0] == 1) {
		lintcopy(x, y);
		return;
	}
	if (x->len == 0 || y->len == 0) {
		lintresetv(x);
		return;
	}
	if (x->len <= 256 && y->len <= 256) {
		lintm0(x, y); return;
	}
	if (x->len >= lintm2minl && y->len >= lintm2minl)
		if (x->len < lintm2maxl && y->len < lintm2maxl) {
			lintm2(x, y); return;
		}
	int n = x->len; if (n < y->len)n = y->len; n = n / 2;
	//int m = 1; while (m < n)m *= 2; n = m;//令后半段的长度是2的幂 并且超过最大长度的一半
	lint *a = NULL, *b = NULL, *c = NULL, *d = NULL, *e = NULL, *f = NULL;
	lintnew(&a); lintnew(&b); lintnew(&c); lintnew(&d); lintnew(&e); lintnew(&f);
	lintm1divmain(x, y, a, b, c, d, e, f, n);
	lintm1(a, c); lintm1(b, d); lintm1(e, f);
	lintm1sum(a, b, e, n);
	lintcopy(x, a);
	lintdelete(&a); lintdelete(&b); lintdelete(&c); lintdelete(&d); lintdelete(&e); lintdelete(&f);
	return;
}
struct comp { double x, y; };
const double pi = acos(-1);
void coswap(comp *a, comp *b) {
	double temp;
	temp = a->x; a->x = b->x; b->x = temp;
	temp = a->y; a->y = b->y; b->y = temp; return;
}
void coa(comp *a, comp *b) {
	a->x += b->x; a->y += b->y; return;
}
void cos(comp *a, comp *b) {
	a->x -= b->x; a->y -= b->y; return;
}
void com(comp *a, const comp b) {
	double x = a->x*b.x - a->y*b.y;
	double y = a->x*b.y + a->y*b.x;
	a->x = x; a->y = y; return;
}
void lintm2_rev(int **rev, int*size, int len) {
	int i, tim = 0, s = 1;
	while (s < len) { s <<= 1; tim++; }
	*rev = new int[s]; for (i = 0; i < s; i++)(*rev)[i] = 0;
	for (i = 0; i < s; i++)(*rev)[i] = ((*rev)[i >> 1] >> 1) | ((i & 1) << (tim - 1));
	*size = s;
	return;
}
void lintm2_FFT(comp*a, const int fla, int *rev, int size) {
	int i, j, k;
	for (i = 0; i < size; i++)if (i < rev[i])coswap(a + i, a + rev[i]);
	for (i = 1; i < size; i <<= 1) {
		const comp w = { cos(pi / i), fla*sin(pi / i) };
		for (j = 0; j < size; j += (i << 1)) {
			comp K = { 1,0 };
			for (k = 0; k < i; k++) {
				com(&K, w);
				comp x = a[j + k], y = a[j + k + i];
				com(&y, K);
				a[j + k] = x; coa(a + j + k, &y);
				a[j + k + i] = x; cos(a + j + k + i, &y);
			}
		}
	}
	for (i = 0; i < size / 2; i++)coswap(a + i, a + size - i - 1);
	return;
}
void lintm2(lint *x, lint *y) {
	int i, j, temp, *rev = NULL, size = 0;
	i = x->len + y->len;
	lintm2_rev(&rev, &size, i * 8);
	//a,b传值
	comp*a = NULL;
	while (a == NULL)a = new comp[size];
	for (i = 0; i < size; i++) { a[i].x = 0; a[i].y = 0; };
	for (i = 0; i < x->len; i++) {
		temp = x->v[i];
		j = 0;
		while (temp > 0) {
			a[i * 8 + j].x = temp % 10;
			temp /= 10;
			j++;
		}
	}
	for (i = 0; i < y->len; i++) {
		temp = y->v[i];
		j = 0;
		while (temp > 0) {
			a[i * 8 + j].y = temp % 10;
			temp /= 10;
			j++;
		}
	}
	//正变换
	lintm2_FFT(a, 1, rev, size);
	//a[i]=a[i].*a[i]
	for (i = 0; i < size; i++)com(a + i, a[i]);
	//反变换
	lintm2_FFT(a, -1, rev, size);
	//归一化
	for (i = 0; i < size; i++)a[i].x = a[i].y / size / 2;
	//x 传值
	long long temp2; int tempf = 0, lenxold = x->len, count = 0;
	lintresetv(x);
	lintchecksize(x, size / 8);
	for (i = 0; i < size; i++) {
		temp2 = (int)(a[i].x + 0.49);
		if (temp2 > 0)count = i;
		tempf = lintafast(x, temp2, i / 8, i % 8);
	}
	x->len = x->size - 1; while (x->v[x->len] == 0)x->len--; x->len++;
	//回收空间
	delete[]rev; delete[]a;
	return;
}
void lintm(lint *a, lint *b, int mode = 2) {
	switch (mode) {
	case 1:lintm0(a, b); return;//原始竖式乘法 o(n^2)
	case 2:lintm1(a, b); return;//分治乘法 o(n^1.59)
	//case 3:lintm1s(a, b); return;//手动设置一个栈的乘法2 o(n^1.59) 优化效果不明显
	case 4:lintm2(a, b); return;//FFT乘法 ≈o(n)
	}
}
void lintm(lint *a, int num, int section = 0, int mode = 2) {
	lintnewstatic(c); lintchecksize(c, section + 1);
	linta(c, num, section);
	lintm(a, c, mode); return;
}
//lint_div
int lintd(lint *a, lint *b) {
	lintnewstatic(c); lintchecksize(c, a->len);
	lintnewstatic(d); lintchecksize(d, a->len);
	lintnewstatic(e); lintchecksize(e, a->len);
	int i;
	while (lintcmp(a, b) != -1) {
		lintresetv(d); linta(d, 1);
		while (1) {
			lintcopy(e, b); lintm(e, d); lintm(e, 10);
			if (lintcmp(a, e) == -1)break;
			lintm(d, 10);
		}
		i = 1;
		while (1) {
			lintcopy(e, b); lintm(e, d); lintm(e, i + 1);
			if (lintcmp(a, e) == -1)break;
			i++;
		}
		lintcopy(e, b); lintm(d, i); lintm(e, d);
		linta(c, d);
		lints(a, e);
	}
	int re = 0;
	lintresetv(d);
	if (lintcmp(a, d) == 0)re = 0; else re = 1;
	i = c->len - 1; while (c->v[i] == 0 && i >= 0)i--; c->len = i + 1;
	lintcopy(a, c);
	return re;
}
void lintd(lint *a, int num, int section = 0) {
	lintnewstatic(c); lintchecksize(c, a->len);
	linta(c, num, section);
	lintd(a, c); return;
}
