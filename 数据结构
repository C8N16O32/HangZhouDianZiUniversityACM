/*======================================================================   目录   ======================================================================*/
5. hashmap template<int Pow, class T=int> struct Hashmapc
6. skiplist用于查找 template<class K = int, class T = int> class Slist
1. 循环队列/栈两用结构 template<class T> class QUEUE
2. 双向循环链表(带有key) template<class T, typename K> class LIST
3. 优先队列 template<class T, typename K> class PRIQUE  需要使用 (1) 与 (2)   将1的对象作为2的模板里的T
4. 点与点阵基类

/*======================================================================   hashmap   ======================================================================*/
//hashmap 缺少删除操作

template<int Pow, class K = int, class T = int>
struct Hashmapd {

	//双散列函数+开放地址法
	static const int pow = Pow, max = 1 << pow //max为2的幂 或者2的幂*1.5 使得系数b1 b2可以简单的取到
		, b1 = max / 7 / 6 * 6 + 1
		, b2 = max / 10 / 6 * 6 + 1;//b1 b2为hash的系数 b2同时还是向后查找的跨度
	int H[max] = {}; T V[max];
	void reset() { for (int i = 0; i < max; i++)H[i] = -1; }

	//hash 暂时写死 需要的时候再改  hash作为下标 hash2作为H填入的值
	int hash(const string&s) { int len = s.length(); long long re = 1; for (int i = 0; i < len; i++)re = (re*b1 + s[i]) % max; return re; }
	int hash2(const string&s) { int len = s.length(); long long re = 1; for (int i = 0; i < len; i++)re = (re*b2 + s[i]) % 2100000000; return re; }
	int hash(int n) { return n % max; }//细节：inline反而变慢，与max-1进行^运算没有显著效果
	int hash2(int n) { return n; }

	int hnext(int h1) { return (h1 + b2) % max; }//双散列函数探查法

	//查改增 首先使用find_impl 然后选择相应的函数执行操作
	int h1, h2; //find_impl的关键变量
	int find_impl(const K&k0) {
		h1 = hash(k0); h2 = hash2(k0);
		while (H[h1] != h2&&H[h1] != -1)h1 = hnext(h1);
		return h1;
	}
	bool isitexist(const K&k0) {
		find_impl(k0); if (H[h1] == h2)return 1;
		else return 0;
	}
	T& getit() { return V[h1]; }
	T& pushit(const T&t) {
		H[h1] = h2;
		V[h1] = t;
		return V[h1];
	}
	//改增 常规
	T& push(const K&k, const T&t) {
		find_impl(k);
		return pushit(t);
	}
	T& get(const K&k) {
		find_impl(k);
		return getit();
	}
};
/*======================================================================   skiplist   ======================================================================*/
//Skiplist
template<class K = int, class T = int>
class Slist {
	//节点最大高度
	static const char pmax = 12;
	//排序模式
	int sortmode = 0; //默认升序: smode=0
public:
	void setsortmode(int smode) { sortmode = smode; }
private:
	//均匀数发生器
	int rmax = 1 << pmax, ra = 0, rb = rmax / 10 / 2 * 2 + 1;
	int rrand() { ra = (ra + rb) % rmax; return ra; }
	int nrand() {
		int c = pmax, r = rrand(), k = r % 2;
		while (c > 1 && r > 1) { r >>= 1; c--; }
		if (c == pmax&&r)c = 1;
		return c;
	};

	//数据节点
	struct Note {
		const char plen; Note**p = NULL;
		K k; T t;
		Note(char plen0) :plen(plen0) { p = new N*[plen](); };
		~Note() { delete[] p; }
	}*head = NULL, *tail = NULL;
	int msize = 0; using N = Note;
public:
	//基本操作
	bool isempty() { if (msize)return 1; return 0; }
	int size() { return msize; }
	N* gettail() { return tail; }
	void set() {
		//建立首尾节点
		head = new N(pmax); tail = new N(pmax);
		for (int i = 0; i < head->plen; i++)head->p[i] = tail;
		msize = 0;
	}
	void reset() {
		//清除中间节点
		if (msize) {
			N*cur = head->p[0], *temp = NULL;
			while (cur != tail) {
				temp = cur->p[0]; delete cur; cur = temp;
			}
		}
		//重置首尾节点
		for (int i = 0; i < head->plen; i++)head->p[i] = tail;
		msize = 0;
	};

	//构造/析构
	Slist() { set(); };
	~Slist() { reset(); delete head; delete tail; };
private:
	//比较
	bool cmp(const K&knext, const K&k) {
		if (sortmode == 0) { if (knext >= k)return 0; }
		else { if (knext <= k)return 0; }
		return 1;
	};

	//查改增删_内部实现
	N* pleft[pmax] = {}; //中间结果
public:
	N* find_impl(const K&k) {
		N*cur = head; int i = pmax - 1;
		while (i >= 0) {
			while (cur->p[i] != tail&&cmp(cur->p[i]->k, k)) { 
				cur = cur->p[i]; 
			}//向右查找
			pleft[i] = cur; i--;//向下
		}
		return pleft[0];
	}
private:
	//根据查找结果 插入节点 删除节点
	void push_impl(N*n) {
		msize++;
		for (int i = 0; i < n->plen; i++) { n->p[i] = pleft[i]->p[i]; pleft[i]->p[i] = n; };
	}
	void erase_impl() {
		msize--; N*n = pleft[0]->p[0];
		for (int i = 0; i < n->plen; i++) pleft[i]->p[i] = n->p[i]; delete n;
	}
public:
	//查改增删_必须先查 一般用于重载[]运算符
	bool isitexist(const K&k) {
		find_impl(k);
		if (pleft[0]->p[0] == tail)return 0;
		return pleft[0]->p[0]->k == k;
	}
	T& getit() { return pleft[0]->p[0]->t; }
	T& pushit(const K&k, const T&t) {
		N*cur = new N(nrand()); cur->k = k; cur->t = t;
		push_impl(cur); return cur->t;
	}
	void eraseit() { erase_impl(); }
	//遍历模板
	template<class F2, class ...T2>
	void foreachk(F2 f, T2 ...args) {
		N*cur = head->p[0];
		while (cur != tail) {
			f(cur->k, args...);
			cur = cur->p[0];
		}
	}
	template<class F2, class ...T2>
	void foreacht(F2 f, T2 ...args) {
		N*cur = head->p[0];
		while (cur != tail) {
			f(cur->t, args...);
			cur = cur->p[0];
		}
	}
	//改增 常规
	T& push(const K&k, const T&t) {
		find_impl(k);
		return push_impl(k, t);
	}
	T& get(const K&k) {
		find_impl(k);
		return getit();
	}
};

BFS/DFS
BFS使用队列，有时可以使用队列链表实现优先队列
DFS有多种用法 通常使用栈，但是要在T里放回调标志与回调函数
简陋： 队列/栈的大小发生改变时 元素的引用或指向元素的指针会失效。应在失效前进行操作 或者在必要的时候重新获得引用或指向元素的指针
/*======================================================================   循环队列/栈   ======================================================================*/
template<class T>
class QUEUE{
	int mhead = 0, mend = 0, mcapacity = 0; T*v = NULL;
	bool isempty() { if (mend == mhead)return 1; return 0; }
	int size() { return mend - mhead; }
	int mcapadef = 16, mheat = 0, mheatdef = 8;
	//动态数组
	void changecapacity(int capanew) {
		int s1 = mhead, l1 = size(), s2 = 0, l2 = 0;
		if (mend > mcapacity) { l2 = mend - mcapacity; l1 = mcapacity - mhead; }
		T*temp = new T[capanew]; int i;
		for (i = s1; i < s1 + l1; i++)temp[i - s1] = v[i]; 
		for (i = s2; i < s2 + l2; i++)temp[i - s2 + l1] = v[i];
		delete[]v; v = temp; temp = NULL;
		mhead = 0; mend = l1 + l2; mcapacity = capanew;
	}
	void checkcapacity(int needone) {
		int capaneed = needone + size(), capanew = mcapadef;
		while (capanew < capaneed)capanew *= 2;
		if (capanew > mcapacity) { changecapacity(capanew); mheat = mheatdef; return; }
		if (mheat > 0) { mheat--; return; }
		if (capanew < mcapacity) { changecapacity(capanew); mheat = mheatdef; return; }
	}
	//输入输出
	void push_end(const T&x) { checkcapacity(1); v[mend%mcapacity] = x; mend++; }
	//以下四个执行前必须检查isempty
	T&head() { return v[mhead]; }
	T&rhead() { return v[(mend - 1) % mcapacity]; }
	void pop_head() { mhead++; if (mhead == mcapacity) { 
		mhead = 0; mend -= mcapacity; }checkcapacity(0); }
	void pop_end() { mend--; checkcapacity(0); }
	//构造/析构
	void Reset() { delete[]v; v = NULL; mhead = 0; mend = 0; mcapacity = 0; }
	~queue() { if (v != NULL)Reset(); };
	void operator=(const queue<T>&y) { 
		Reset(); mcapadef = y.mcapadef; mheat = 0; mheatdef = y.mheatdef; 
		if (!y.isempty()) {
			v = new T[y.mcapacity]; mcapacity = y.mcapacity; for (int i = y.mhead; i < y.mend; i++)
				v[i%mcapacity] = y.v[i%mcapacity]; mhead = y.mhead; mend = y.mend; 
		} 
	}
};
/*======================================================================   双向循环链表   ======================================================================*/
//双向循环链表 (含有key)
template<class T, typename K>
class LIST {
public:
	struct N {
		K key; T data;
		N*next = NULL, *prev = NULL;
	};
private:
	//数据
	struct N *m_head = NULL;
	int m_size = 0;
public:
	//信息
	bool isempty() { if (m_size)return 0; return 1; };
	int size() { return m_size; };
	N*head() { return m_head; };
	void sethead(N*newhead) {
		if (m_head == NULL) {
			m_size = 1;
			newhead->next = newhead;
			newhead->prev = newhead;
		};
		m_head = newhead;
	};
	//增查删
	void insert(N *px, N *ppre = NULL) {
		//首节点
		if (ppre == NULL) {
			m_head = px;
			m_head->prev = m_head;
			m_head->next = m_head;
		}
		//常规
		else {
			N *pnex = ppre->next;
			px->prev = ppre; ppre->next = px;
			px->next = pnex; pnex->prev = px;
		};
		m_size++;
		return;
	};
	N*search(K key) {
		if (isempty())return NULL;
		N *cur = m_head;
		for (int i = 0; i < m_size; i++) {
			if (cur->key == key)return cur;
			cur = cur->next;
		};
		return NULL;
	};
	void erase(N *px) {
		//最后一个节点
		if (m_size == 1) {
			delete m_head; m_head = NULL;
		}
		else {
			px->prev->next = px->next;
			px->next->prev = px->prev;
			if (px == m_head)m_head = px->next;
			delete px; px = NULL;
		};
		m_size--;
		return;
	};
	//构造/析构
	virtual ~LIST() {
		if (isempty())return;
		while (m_head)erase(m_head);
	};
};
/*======================================================================   优先队列   ======================================================================*/
//优先队列 (队列链表实现)
template<class T, typename K>
class PRIQUE {
public:
	using Q = QUEUE<T>;
	LIST<Q, int> list;
	using N = typename LIST<Q, int>::N;
	void push(T &data, int count) {
		auto push_queue = [&](N*note, T &data) {note->data.push_end(data); };
		auto push_list = [&](T &data, int key) {
			N *temp = new N;
			temp->data.push_end(data); temp->key = key;
			if (list.isempty()) { list.sethead(temp); return; };
			int size = list.size();
			N *cur = list.head();
			int i; for (i = 0; i < size; i++) {
				if (key < cur->key)break;
				cur = cur->next;
			};
			list.insert(temp, cur->prev);
			if (i == 0 && cur == list.head())list.sethead(temp);
		};

		N*s = list.search(count);
		if (s)push_queue(s, data);
		else push_list(data, count);
	};
	bool isempty() {
		if (list.isempty())return 1; return 0;
	};
	//请使用isempty()提前检查
	T pop() {
		T temp;
		Q&q = list.head()->data;
		temp = q.head(); q.pop_head();
		if (q.isempty())list.erase(list.head());
		return temp;
	};
};
/*======================================================================   点与点阵基类   ======================================================================*/
struct P { int i, j; bool operator==(const P&y) { if (y.i == i&&y.j == j)return 1; return 0; } };
template<class T>
struct square {
	int m = 0, n = 0; T**v = NULL;
	void New(int im, int in) { m = im; n = in; v = new T*[m]; for (int i = 0; i < m; i++)v[i] = new T[n]; }
	void Del() { for (int i = 0; i < m; i++)delete[]v[i]; delete[]v; v = NULL; m = 0; n = 0; }
	~square() { if (v != NULL)Del(); };
	template<class F, class ...Ft>void For_each(F f, Ft ...args) { for (int i = 0; i < m; i++)for (int j = 0; j < n; j++)f(v[i][j], args...); }
	template<class F, class ...Ft>void For_each_ij(F f, Ft ...args) { for (int i = 0; i < m; i++)for (int j = 0; j < n; j++)f(i, j, v[i][j], args...); }
	void Reset(const T&valuedefault) { For_each([&](T &v) {v = valuedefault; }); }
	//题目不会给出找不到起点或找不到终点的情况
	void find(const T&valuetarget, P&f) { For_each_ij([&](int i, int j, T&v) {if (v == valuetarget) { f = { i,j }; return 1; } return 0; }); }
	bool isinrect(const P&p) { int i = p.i, j = p.j; if (i < 0 || i >= m || j < 0 || j >= n)return 0; return 1; }
	//仅支持相同大小的两个结构进行赋值运算
	void operator=(const square&y) { if (v == NULL)New(y.m, y.n); For_each_ij([&](int i, int j, T&v) {v = y.v[i][j]; }); }
};
/*======================================================================   end   ======================================================================*/
