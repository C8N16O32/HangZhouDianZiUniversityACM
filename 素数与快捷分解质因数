//素数&素数因子
struct pri { int*prik = NULL, *priflag = NULL, *priv = NULL, prisize = 0; };
void priset(pri*a, int prisize) {
	//开辟筛查表
	a->priflag = new int[prisize];
	int i = 0, j = 0, k = 1;
	for (i = 0; i < prisize; i++)a->priflag[i] = 0;
	//特殊筛质数
	for (i = 2; i < prisize; i++)
		if (!a->priflag[i]) {
			for (j = i * 1; j < prisize; j += i)
				a->priflag[j] = k;
			k++;
		}
	//检查质数个数
	j = 0;
	for (i = 2; i < prisize; i++)if (j < a->priflag[i])j = a->priflag[i];
	//质数表
	a->prik = new int[j];
	i = 2; j = 0; k = 0;
	for (i = 2; i < prisize; i++)if (j < a->priflag[i]) { j = a->priflag[i]; a->prik[k] = i; k++; }
	prisize = k;
	//质因数表
	a->priv = new int[prisize];
	for (i = 0; i < prisize; i++)
		a->priv[i] = 0;
	a->prisize = prisize;
	return;
}
void priset(pri**ap, int prisize) {
	if (*ap == NULL)*ap = new pri;
	priset(*ap, prisize); return;
}
void privreset(pri*a) {
	int i; for (i = 0; i < a->prisize; i++)a->priv[i] = 0; return;
}
void pridelete(pri*a) {
	delete[] a->priflag; a->priflag = NULL;
	delete[] a->prik; a->prik = NULL;
	delete[] a->priv; a->priv = NULL;
	a->prisize = 0; return;
}
//分解质因数-一个数字
void prif1(pri *a, int num, int mode = 1) {
	if (num <= 1)return;
	int priord = 0;
	//分解质因数
	while (a->priflag[num]) {
		priord = a->priflag[num] - 1;
		a->priv[priord] += mode;
		num /= a->prik[priord];
	}
	return;
}
//分解质因数-阶乘
void priffact(pri *a, int num, int mode = 1) {
	int i;
	for (i = 2; i <= num; i++)
		prif1(a, i, 1);
	return;
}
//分解质因数-排列数
void prifcnm(pri *a, int n, int m) {
	if (n - m < m)m = n - m; int i;
	//re=n!/(n-m)!
	for (i = n - m + 1; i <= n; i++)
		prif1(a, i, 1);
	//re=re/m!
	for (i = 1; i <= m; i++)
		prif1(a, i, -1);
	return;
}
//质因数表导出为大数
void pri2lint(pri *a, lint *b) {
	int i, k, ti, tb, tk = 2, tmin = 16;
	lint *base = NULL, *temp[32] = { NULL };
	lintnew(&base);
	for (i = 0; i < 32; i++) { lintnew(temp + i); linta(temp[i], 1); }

	int TI = 0;
	if (a->priv[0]>0 && a->priv[2]>0) {//末尾的0
		ti = a->priv[2]; if (ti > a->priv[0])ti = a->priv[0];
		ti = ti / 8; a->priv[0] -= ti * 8; a->priv[2] -= ti * 8;
		TI = ti;
	}
	for (i = 0; i < a->prisize; i++)
		if (a->priv[i]) {
			k = a->priv[i];
			lintresetv(base); linta(base, 1); lintm(base, a->prik[i]);
			while (k) {
				if (k % 2) {
					ti = 0; tb = tmin;
					while (base->len > tb) { tb *= tk; ti++; }
					lintm(temp[ti], base);
					while (temp[ti]->len >= tb) {
						lintm(temp[ti + 1], temp[ti]);
						lintresetv(temp[ti]); linta(temp[ti], 1);
						tb *= tk; ti++;
					}
				}
				if (k == 1)break;
				lintm(base, base);
				k = k / 2;
			}
		}
	for (i = 0; i < 32; i++)lintm(b, temp[i]);
	//末尾的0
	if (TI) {
		lintchecksize(b, b->len + TI);
		for (i = b->len + TI - 1; i >= TI; i--)b->v[i] = b->v[i - TI];
		for (i = 0; i < TI; i++)b->v[i] = 0;
		b->len += TI;
	}
	lintdelete(&base);
	for (i = 0; i < 32; i++)lintdelete(temp + i);
	return;
}
