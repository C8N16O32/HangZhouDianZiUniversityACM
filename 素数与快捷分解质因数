//素数&素数因子
struct pri { int*prik = NULL, *priflag = NULL, *priv = NULL, prisize = 0; };
void priset(struct pri**a,int prisize) {
	if (*a == NULL)*a = new struct pri;
	(*a)->priflag = new int[prisize];
	int i = 0, j = 0, k = 1;
	for (i = 0; i < prisize; i++)(*a)->priflag[i] = 0;
	for (i = 2; i < 230; i++)
		if (!(*a)->priflag[i]) {
			for (j = i * 2; j < prisize; j += i)
				(*a)->priflag[j] = k;
			k++;
		}
	j = 0;
	for (i = 2; i < prisize; i++)if ((*a)->priflag[i] == 0)j++;
	(*a)->prik = new int[j];
	i = 0; j = 2;
	while (j < prisize) { if ((*a)->priflag[j] == 0) { (*a)->prik[i] = j; i++; }j++; }
	prisize = i;

	(*a)->priv = new int[prisize];
	for (i = 0; i < prisize; i++)
		(*a)->priv[i] = 0;
	(*a)->prisize = prisize;
	return;
}
void privreset(struct pri*a) {
	int i; for (i = 0; i < a->prisize; i++)a->priv[i] = 0; return;
}
void pridelete(struct pri*a) {
	delete[] a->priflag; a->priflag = NULL;
	delete[] a->prik; a->prik = NULL;
	delete[] a->priv; a->priv = NULL;
	a->prisize = 0; return;
}
//素数因子计数-一个数字
void prif1(pri *a, int num, int mode = 1) {
	if (num <= 1)return;
	int priord = 0;
	//合数
	while (a->priflag[num]) {
		priord = a->priflag[num] - 1;
		a->priv[priord] += mode;
		num /= a->prik[priord];
	}
	//现在数据是质数
	if (num == a->prik[priord]) { a->priv[priord] += mode; return; }
	int low = 0, high = a->prisize - 1;
	while (low <= high) {
		priord = (low + high) / 2;
		if (a->prik[priord] == num)break;
		if (a->prik[priord] > num)
			high = priord - 1;
		else
			low = priord + 1;
	}
	a->priv[priord] += mode;
	return;
}
//素数因子计数-排列数
void prifcnm(struct pri *a,int n, int m) {
	if (n - m < m)m = n - m; int i;
	privreset(a);
	//re=n!/(n-m)!
	for (i = n - m + 1; i <= n; i++)
		prif1(a, i, 1);
	//re=re/m!
	for (i = 1; i <= m; i++)
		prif1(a, i, -1);
}
//素数因子导出
void pri2lint(struct pri *a, struct lint *b) {
	int i, k, ti, tb, tk = 2, tmin = 16;
	struct lint *base = NULL, *temp[32] = { NULL };
	lintnew(&base);
	for (i = 0; i < 32; i++) { lintnew(temp + i); linta(temp[i], 1); }

	for (i = 0; i < a->prisize; i++)
		if (a->priv[i]) {
			k = a->priv[i];
			lintresetv(base); linta(base, 1); lintm(base, a->prik[i]);
			while (k) {
				if (k % 2) {
					ti = 0; tb = tmin;
					while (base->len > tb) { tb *= tk; ti++; }
					lintm(temp[ti], base);
					while (temp[ti]->len >= tb) {
						lintm(temp[ti + 1], temp[ti]);
						lintresetv(temp[ti]); linta(temp[ti], 1);
						tb *= tk; ti++;
					}
				}
				if (k == 1)break;
				lintm(base, base);
				k = k / 2;
			}
		}
	for (i = 0; i < 32; i++)lintm(b, temp[i]);
	lintdelete(&base);
	for (i = 0; i < 32; i++)lintdelete(temp + i);
	return;
}
