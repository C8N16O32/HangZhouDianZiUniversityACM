//素数&素数因子
struct pri { int*prik = NULL, *priflag = NULL, *priv = NULL, prisize = 0; };
void priset(pri*a,int prisize) {
	a->priflag = new int[prisize];
	int i = 0, j = 0, k = 1, I = 0;
	for (i = 0; i < prisize; i++)a->priflag[i] = 0;
	i = 1; while (i*i < prisize&&i*i>0)i++; I = i;
	for (i = 2; i < I; i++)
		if (!a->priflag[i]) {
			for (j = i * 2; j < prisize; j += i)
				a->priflag[j] = k;
			k++;
		}
	j = 0;
	for (i = 2; i < prisize; i++)if (a->priflag[i] == 0)j++;
	a->prik = new int[j];
	i = 0; j = 2;
	while (j < prisize) { if (a->priflag[j] == 0) { a->prik[i] = j; i++; }j++; }
	prisize = i;

	a->priv = new int[prisize];
	for (i = 0; i < prisize; i++)
		a->priv[i] = 0;
	a->prisize = prisize;
	return;
}
void priset(pri**ap, int prisize) {
	if (*ap == NULL)*ap = new pri;
	priset(*ap, prisize); return;
}
void privreset(pri*a) {
	int i; for (i = 0; i < a->prisize; i++)a->priv[i] = 0; return;
}
void pridelete(pri*a) {
	delete[] a->priflag; a->priflag = NULL;
	delete[] a->prik; a->prik = NULL;
	delete[] a->priv; a->priv = NULL;
	a->prisize = 0; return;
}
//素数因子计数-一个数字
void prif1(pri *a, int num, int mode = 1) {
	if (num <= 1)return;
	int priord = 0;
	//合数
	while (a->priflag[num]) {
		priord = a->priflag[num] - 1;
		a->priv[priord] += mode;
		num /= a->prik[priord];
	}
	//现在数据是质数
	if (num == a->prik[priord]) { a->priv[priord] += mode; return; }
	int low = 0, high = a->prisize - 1;
	if (num < a->prik[priord])high = priord - 1;
	while (low <= high) {
		priord = (low + high) / 2;
		if (a->prik[priord] == num)break;
		if (a->prik[priord] > num)
			high = priord - 1;
		else
			low = priord + 1;
	}
	a->priv[priord] += mode;
	return;
}
//素数因子计数-排列数
void prifcnm(pri *a,int n, int m) {
	if (n - m < m)m = n - m; int i;
	privreset(a);
	//re=n!/(n-m)!
	for (i = n - m + 1; i <= n; i++)
		prif1(a, i, 1);
	//re=re/m!
	for (i = 1; i <= m; i++)
		prif1(a, i, -1);
}
//素数因子导出
void pri2lint(pri *a, lint *b) {
	int i, k, ti, tb, tk = 2, tmin = 16;
	lint *base = NULL, *temp[32] = { NULL };
	lintnew(&base);
	for (i = 0; i < 32; i++) { lintnew(temp + i); linta(temp[i], 1); }

	int TI = 0;
	if (a->priv[0]>0 && a->priv[2]>0) {//末尾的0
		ti = a->priv[2]; if (ti > a->priv[0])ti = a->priv[0];
		ti = ti / 8; a->priv[0] -= ti * 8; a->priv[2] -= ti * 8;
		TI = ti;
	}
	for (i = 0; i < a->prisize; i++)
		if (a->priv[i]) {
			k = a->priv[i];
			lintresetv(base); linta(base, 1); lintm(base, a->prik[i]);
			while (k) {
				if (k % 2) {
					ti = 0; tb = tmin;
					while (base->len > tb) { tb *= tk; ti++; }
					lintm(temp[ti], base);
					while (temp[ti]->len >= tb) {
						lintm(temp[ti + 1], temp[ti]);
						lintresetv(temp[ti]); linta(temp[ti], 1);
						tb *= tk; ti++;
					}
				}
				if (k == 1)break;
				lintm(base, base);
				k = k / 2;
			}
		}
	for (i = 0; i < 32; i++)lintm(b, temp[i]);
	//末尾的0
	if (TI) { 
		lintchecksize(b, b->len + TI); 
		for (i = b->len + TI - 1; i >= TI; i--)b->v[i] = b->v[i - TI];
		for (i = 0; i < TI; i++)b->v[i] = 0;
		b->len += TI;
	}
	lintdelete(&base);
	for (i = 0; i < 32; i++)lintdelete(temp + i);
	return;
}
